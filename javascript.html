<!doctype html>

<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>JavaScript in a Jiffy</title>
    <meta name="description" content="An incredibly quick introduction to HTML, CSS, and JavaScript">
    <meta name="author" content="Brian Hayes">

    <link rel="stylesheet" href="css/workshop.css">
    <link rel="stylesheet" href="css/prism.css">
    <link rel="stylesheet" href="css/codemirror.css">
    <link rel="stylesheet" href="css/solarized.css">
    <link rel="stylesheet" href="css/footnotes.css">

  </head>

  <body>
    <div id="content"> 
      <div id="header">
        <h3>NESW Workshop</h3>
        <h3>Telling Science Stories with Code and Data</h3>   
      </div>
      <div id="nav"></div>

      <h2>JavaScript in a Jiffy</h2>
      <h5 class="byline">by Brian Hayes</h5>
      
      <p>The world’s computers run more programs written in JavaScript than in any other language. The reason for this huge popularity is not any special virtue of the language itself. The big reason for writing in JavaScript is that you can publish your work on the Web, and anyone with a browser can run your program without having to download or install anything. If you are writing a story that’s going to be read online, JavaScript allows you to go beyond words and pictures, creating animated or interactive elements that are instantly available to your readers.</p>
      
      <p>These computational aids to storytelling open up a whole new channel of communication, a new way of presenting data or explaining ideas. They are especially useful in science writing, where we often have intellectually challenging material to get across. Consider the <a href="http://vizhub.healthdata.org/us-health-map/">U.S. Health Map</a>, which distills data on more than 3,000 U.S. counties into a form that allows you to step back and see overall patterns or drill down for the details. Or take the <a href="http://cliffcrosland.tumblr.com/post/115981256393/black-hole-js">JavaScript Black Hole</a>, which vividly illustrates the concept of gravitational lensing in astronomy.</p> 
      
      <p>The <a href="examples.html">Examples</a> page of this website lists several other impressive works in JavaScript (look under the headings Dava Viz and Simulations and Interactive Presentations). Most of those illustrations were created by virtuoso programmers with long experience and deep expertise. A one-day workshop will not bring you up to that level. But it <em>is</em> entirely possible for an amateur to construct engaging and useful web “interactives” that help explain ideas in the sciences. Here’s one of mine:</p> 
      
      <div id="dla-banner-div"><canvas id="dla-banner-canvas" width="500px" height="275px"></canvas></div>
      <button id="dla-run" onclick="dlaBanner.animate()">Run</button>

      <p>Click the <code class="button">Run</code> button. The lacy, fernlike patterns are created by an algorithm called diffusion-limited aggregation, which models many natural processes, from sedimentation on the seafloor to the growth of tumors and bacterial colonies. What you are seeing is not a movie—it’s not an event recorded once and then replayed the same way forever after. Every time you click the button, the simulation runs anew, computing a new pattern. (A version of the program with extra knobs and switches, allowing you to explore and experiment, is available <a href="http://bit-player.org/wp-content/extras/dla/dla.html">here</a>.)</p>
      
      <p>In this tutorial we’re going to explore and experiment with JavaScript itself. You’ll be able to write code directly in this web page, and then run your program to see the results. Before we get started, there are a few preliminaries.</p>
      
      <ul>
        <li>Please open this document in a reasonably up-to-date web browser. Recent versions of Google Chrome or Firefox are ideal; Safari and Opera are also fine. The latest Internet Explorer (IE11) should also work, but I haven’t been able to test it.</li>
        
        <li>For most of the exercises below, you’ll need to use your browser’s developer tools—specifically the JavaScript console—which is where outputs and error messages will appear.</li>
        
        <ul>
          <li>In Chrome, the menu item is View > Developer > JavaScript Console. (<a href="https://developer.chrome.com/devtools">More info.</a>)</li>
          
          <li>In Firefox: Tools > Web Developer > Web Console. (<a href="https://developer.mozilla.org/en-US/docs/Tools">More info.</a>)</li>
          
          <li>In Safari, first open Preferences, find the Advanced tab, tick the box labeled “Show Develop Menu in Menu Bar.” Now, under the new Develop menu, choose “Show Error Console.” (<a href="https://developer.apple.com/safari/tools/">More info.</a>)</li>
          
          <li>In Internet Explorer 11, press F12 to open the Tools window, then select the Console tab. (<a href="https://msdn.microsoft.com/library/ie/bg182326(v=vs.85)">More info.</a>)</li>
          
        </ul>
        <li>You can adjust the size and location of the JavaScript console. When screen space is tight, I like to anchor the console to the right edge of the browser window.</li>
        
        <li>Throughout this tutorial, every panel with a butter-colored background and an orange border is a live JavaScript playground. The <code class="button">Run</code> button just above the panel will run the code. You can edit the code in the panel and run it again, as often as you wish. The panel will grow as needed when you type more lines of code.</li>
        
        <li><span class="peekaboo-ref" id="underlines">Underlined text</span> in this tutorial signals the presence of a peekaboo note: click to reveal it, then click again to hide it. Most of the notes elaborate on gnarly technical details, and there’s no harm in skipping them if you can suppress your curiosity.</li>
        
        <p id="note-underlines" class="peekaboo-note shuttered">The other notes are more informative than this one, I promise.</p>
      
      </ul>
      
      <h4>The JavaScript Playground</h4>
      
      <p>This is what JavaScript looks like in its native habitat:</p>
      
      <div class="cm-div" id="fibo" data-output-height="200px">
      <textarea class="cm">
/*
Compute the nth Fibonacci number. This sequence
begins with 0 and 1, then each subsequent term
is the sum of the two preceding terms. Thus we
get 0, 1, 1, 2, 3, 5, 8, 13, . . .
*/

function fib(n) {
  var a = 0, b = 1, tmp;
  for (var i = 0; i &lt n; i = i + 1) {
    tmp = a;        // save old value of a
    a = b;
    b = b + tmp;
  }
  return a;
}

for (var i = 0; i &lt;= 20; i++) {
  console.log(i, fib(i));
}
</textarea>
     </div>
      
      <p>You may not fully understand the program above—and if you do, you might as well skip the rest of this tutorial—but you can play with it anyway. Go ahead and run the program. With your JavaScript console open, press the <code class="button">Run</code> button and you’ll see the program’s output in the console. Try editing the code, and then run it again to see the effect of your changes. For example, in line 18 you might change <code class="language-javascript">i &lt;= 20</code> to <code class="language-javascript">i &lt;= 50</code> to see some larger Fibonacci numbers. Or make line 9 read <code class="language-javascript">var a = 2, b = 1, tmp;</code> to generate a slightly less famous sequence known as the Lucas numbers. Another <span class="peekaboo-ref" id="phi">experiment worth trying:</span> Change line 15 to <code class="language-javascript">return b / a;</code>. Or just go wild—modify the code in anyway you want, or replace if with your own program. If you ever want to get back to the original state of the code, that’s what the <code class="button">Reset</code> button is for. You can also clear the list of past outputs in the console window, although the command for doing so differs from browser to browser.</p>
      
      <p id="note-phi" class="peekaboo-note shuttered">The ratio of successive Fibonacci numbers converges to a number called phi, also known as the golden ratio. The numerical value is about 1.618. If you’re into this sort of thing, you might want to try the experiment and see what value the ratio of successive Lucas numbers converges to.</p>
      
      <p>What if you make a mistake? It won’t be the first time a computer program has had a bug in it. With some kinds of errors, the program will run but give a wrong answer. More likely, it won’t run at all, and you’ll see an error message in the console. The most annoying goofs are those that cause the program to run forever—to enter an <em>infinite loop</em>. If you’re lucky, the browser will complain about a script that’s taking too long and offer you an opportunity to stop it. Otherwise, you may have to close the tab or window, or even shut down your browser.</p>
      
      <p>One more thing before moving on. Notice in line 20 the phrase <code class="language-javascript">console.log( ... );</code>. This command is how we direct output to the JavaScript console. Anything inside the parentheses is printed on the console. In a finished program, <code class>console.log</code> commands almost never appear, but they are a useful way of peeking inside the program during development and testing. In this tutorial they are the communications channel we need to have a dialogue with JavaScript.</p>
      
      <p>Give it a try in the editor panel below. I have filled in the tired old greeting that has been a cliché of programming language manuals for almost 40 years. Improve on it! Personalize it. Add some more <code>console.log</code> statements of your own. Try putting other kinds of values in the parentheses—maybe an arithmetic expression such as <code class="language-javascript">6 * 7</code>. Again, press the <code class="button">Run</code> button and make sure the result in the console is what you expected to see.</p>
      
<div class="cm-div" id="hello" data-output-height="50px">
<textarea class="cm">console.log("Hello, world!");
</textarea>
</div>      
      
      <h4>Functions</h4>
      
      <p>Where to start in learning a language? Do you memorize a bunch of words and rules, or just plunge into conversation? I favor the latter strategy, and so I am going to start with fully formed sentences rather than individual words. We’ll worry about spelling and punctuation later.</p>
      
      <p>Functions are the basic units of discourse in JavaScript, roughly analogous to sentences or paragraphs of English prose. Here are a few one-liners. You can probably guess what they do, but run the code anyway.</p>
            
<div class="cm-div" id="funcs" data-output-height="80px">
<textarea class="cm">
function fahrenheit(celsius) { return celsius * (180 / 100) + 32; }

function square(n) { return n * n; }

function coinFlip() { return Math.random() &lt; 0.5; }

console.log(fahrenheit(37));
console.log(square(12));
console.log(square(15));
console.log(coinFlip());

</textarea>
</div>
           
      <p>Lines 1, 3, and 5 are function <em>definitions</em>. They create the function—in effect, teaching JavaScript a new trick—but they don’t actually compute anything. The computing happens when you <em>call</em> (or <em>invoke</em> or <em>execute</em>) the function. Each of the <code>console.log</code> statements in lines 7 through 10 calls one of the functions we have just defined.</p>
      
      <p>A function definition has four parts:</p>
      
      <ul>
        <li>The keyword <code>function</code>, which tells the JavaScript interpreter that you’re about to introduce a new function.</li>
        
        <li>A <span class="peekaboo-ref" id="fn-name">name</span> for the new function, such as <code>fahrenheit</code> or <code>coinFlip</code>.</li>
        
        <p id="note-fn-name" class="peekaboo-note shuttered">The name is optional; you can define anonymous functions, but we’re not going to do so here.</p>
         
        <li>A list of <em>parameters</em>, which serve as names for the inputs to the function. When you call the function, you’ll supply values for the parameters. The parameter list is enclosed in parentheses. The list can be empty, but the parentheses must be there.</li>
        
        <li>The body of the function, enclosed in curly braces. These are the statements that will be executed whenever the function is called. If the body includes a <code>return</code> statement, the value computed by that statement is returned as the value of the entire function.</li>
      </ul>
      
      <p>To call a function, just write its name followed by a pair of parentheses enclosing the values that will become inputs (or <em>arguments</em>) to the function. For example, consider the function <code>square</code>, which is defined above with the parameter list <code>(n)</code> and the body <code>{ return n * n }</code>. Invoking this function as <code>square(12)</code> gives the parameter <code>n</code> a value of 12, and so the computation done in the body of the function is 12 &times; 12 = 144. Calling <code>square(15)</code>, on the other hand, returns 225.</p>
           
      <p>Some functions are associated with or belong to a particular object in the JavaScript system. They are known as <em>methods</em>, and there is a special “dotted” syntax for calling them. We have already met two such methods. In <code>console.log()</code>, the <code>log()</code> function is a method of the <code>console</code> object. Similarly in <code>Math.random()</code>, the <code>random()</code> function is a method of an object named Math. <code>Math.random()</code> returns a random number between 0 and 1.</p>
            
      <p>Exercise: Write a function <code>celsius</code> that does the inverse of <code>fahrenheit</code>. You can insert the definition anywhere you wish in the panel above, then write a <code>console.log()</code> statement that tests your function for the Fahrenheit values 32 and 212. (If you’re stuck, here’s <span class="peekaboo-ref" id="celsius-answer">my answer</span>.)</p>
      
      <p id="note-celsius-answer" class="peekaboo-note shuttered"><code class="language-javascript">function celsius(fahrenheit) { return (fahrenheit - 32) * (100 / 180); }</code></p>
      

      
      <h4>Back to Basics</h4>
      
      <p>It’s time to build up some vocabulary and learn the minutiae of spelling, grammar, and puctuation.</p>
      
      <p>The simplest elements of JavaScript are numbers, text strings, and <span class="peekaboo-ref" id="booleans">boolean truth values.</span></p>
      
      <p id="note-booleans" class="peekaboo-note shuttered">Named for the 19th-century logician George Boole.</p>
      
      <ul>
        <li>Some numbers: <code class="language-javascript">1, -42, 3.14159, 6.02e23, 0x00ff88, Infinity</code>. Numbers can be written in various ways: as integers, as decimal values, in scientific notation. Under the hood, they’re all the same—so-called floating-point numbers.</li>
        
        <li>Some text strings: <code class="language-javascript">"a", 'a', "", "A 'string' within a string.", "2.78"</code>. The quotation marks can be either single or double; whichever you choose, the other kind can appear inside the quoted string. Note that <code>2.78</code> is a number but <code>"2.78"</code> is a string of four characters. And <code>""</code> is a string of zero characters.</li>
        
        <li>Some booleans: <code class="language-javascript">true, false</code>. In fact, this is <em>all</em> the booleans; there’s no <code>maybe</code> in between <code>true</code> and <code>false</code>. (JavaScript <em>does</em> classify various kinds of data as  <em>truthy</em> or <em>falsy</em>, but for now it’s best to leave all that to the Colbert Report.)</li>
        
        <li>Stuff I forgot to mention: <code class="language-javascript">undefined, null, NaN</code>. These are various ways of saying “There ain’t no such thing.” You may see them in error messages in the JavaScript console. <code>NaN</code> stands for “not a number”; it’s what you get when you try to do something absurd like taking the square root of <code>"petunias"</code>.</li>
      </ul>
      
      <p>This is a good place to mention a few other niggling details. These rules are JavaScript analogues of “<em>i</em> before <em>e</em> except after <em>c</em>.”
      
      <ul>
        <li>Whitespace, line breaks, and indentation are generally ignored by the JavaScript system. There are useful conventions for formatting JavaScript code, and the editor panels in this tutorial will help you follow them, but those guidelines are for the benefit of human readers; the interpreter doesn’t care. In this respect JavaScript is quite different from Python, where indentation determines grouping and meaning.</li>
        
        <li>When you count things in JavaScript, you start from 0, not from 1. For example, if an array has five items, they are numbered 0, 1, 2, 3, 4. (See below for more on arrays.)</li>
        
        <li>Semicolons and curly braces are sprinkled liberally (but not randomly!) over JavaScript programs. The semicolon is a statement separator; it tells the interpreter where one statement ends and the next begins. You don’t need a semicolon after the <em>last</em> statement in a sequence of statements, but it does no harm to put one there. If you omit a required semicolon, the interpreter will often supply it for you, but it’s risky to count on that. Curly braces group multiple statements into a block that’s treated as a single statement.</li>
        
        <li>Comments, which are strictly for human readers and are ignored by the interpreter, can be written in two ways. A double slash introduces a comment that extends to the end of the current line: <code class="language-javascript">// a one-liner</code>. A comment bracketed with <code class="language-javascript">/* ... */</code> can extend over multiple lines.</li>
      </ul>
           
      <h4>Doing Things with Numbers and Strings</h4>
      
      <p>Arithmetic in JavaScript is quite conventional. The symbols <code>+, -, *, /</code> denote the four familiar operations that Lewis Carroll called ambition, distraction, uglification and derision. There’s also <code>%</code>, which calculates not percentage but remainder after division: <code class="language-javascript">5 % 2 == 1</code>. Other numerical operations live in the <code>Math</code> object (the capital letter is important). For example, <code>Math.floor(n)</code> returns the integer part of <code>n</code>, and <code>Math.pow(x, y)</code> returns <code>x</code> raised to the <code>y</code>th power.</p>
           
      <p>Text strings have their own set of operations, most of them implemented as methods belonging to the strings themselves. In the first line below, we create a string and assign it to the variable <code>s</code>. (More on variables and assignments in just a bit.) Then we invoke four of the methods of the string object <code>s</code>. Before running the code, you might record as a comment following the double slash on each line the value that you expect the expression to return.</p>

<div class="cm-div" id="strings" data-output-height="80px">           
<textarea class="cm">
var s = "Tangles of string theory."
console.log(s.toUpperCase());    // 
console.log(s.charAt(3));        // 
console.log(s.indexOf("g"));     // 
console.log(s.split(" "));       // 
</textarea>
</div>
       
      <p>Observe that <code>s.split(" ")</code> splits the string at every instance of the space character, <code>" "</code>. What do you suppose <code>s.split("")</code> would return, where the argument is not a space character but an empty string? There’s an easy way to find out.</p>
      
      <p>The joker among all these numeric and alphabetic operations is the plus sign, which works on <em>both</em> numbers and text strings but in different ways. There’s not much mystery in an expression such as <code>50 + 7</code>; it yields a value of <code>57</code>. In JavaScript, <code>+</code> also acts on strings, performing not addition but concatenation. (Carroll might have called this one <em>concussion</em>.) Thus <code>"fifty" + "seven"</code> returns a value of <code>"fiftyseven"</code>. What about <code>"50" + "7"</code>? Well, the two operands are not numbers but strings, so they get concatenated rather than added; the value is <code>"507"</code>. The trickiest case is <code>50 + "7"</code>, where one operand is a number and the other a string. Whatever will happen to them? Try the experiment!</p>
      
            
      <h4>Arrays and Objects</h4>
      
      <p>Numbers, booleans, and strings are the atoms and molecules of computational matter. They are building blocks from which you can make higher-level structures. The two main composite structures are called <em>arrays</em> and <em>objects</em>.</p>
      
      <p>An array is written as a list of items separated by commas and enclosed in square brackets:</p>
      
      <ul>
        <li><code class="language-javascript">[2, 3, 5, 7, 11, 13]</code></li>
        <li><code class="language-javascript">["melon", "avocado", "pizza"]</code></li>
        <li><code class="language-javascript">[]</code></li>
        <li><code class="language-javascript">[1, 2, "buckle my shoe", null]</code></li>
        <li><code class="language-javascript">["a", ["b", "c"], [[]]]</code></li>
      </ul>
      
      <p>As these example show, the items in an array can be numbers or text strings or other data elements, and a single array can hold elements of diverse types. And there’s nothing wrong with an empty array, or with arrays of arrays.</p>
      
      <p>An array is an <em>ordered</em> collection of items. This is essential to its nature: the items are numbered, counting up from 0. Storing items, retrieving them, or modifying them—it’s all done by the numbers. In the panel below we define two arrays, called <code>nouns</code> and <code>verbs</code>, each with seven elements. Then we can access any element of the arrays with the notation <code>nouns[i]</code> or <code>verbs[i]</code>, where the index <code>i</code> is an integer between 0 and 6. The <code>console.log</code> statement on line 6 selects three items to construct a rudimentary English sentence.</p>

<div class="cm-div" id="arrays" data-output-height="80px">
<textarea class="cm">var nouns = ["the muffin", "children", "sycamores", "zombies", "grumpiness",
"Big Papi", "spaghetti"];
var verbs = ["created", "adored", "believed in", "motivated", "confused",
"beleagured", "stomped"];

console.log(nouns[5], verbs[6], nouns[0]);
</textarea>
</div>
          
      <p>Try modifying the <code>console.log</code> statement to generate a different sentence. Or insert a statement such as <code class="language-javascript">verbs[6] = "sniffed"</code> on line 5 to replace one of the words. Feeling adventurous? In selecting an array element, the expression inside the square brackets doesn’t have to be a plain number; it could be any expression that yields a number in the appropriate range, such as <code class="language-javascript">verbs[1 + 4]</code>. The JavaScript fragment <code class="language-javascript">Math.floor(Math.random() * 7)</code> returns a random integer between 0 and 6. Can you use this expression to generate some random nonsense about Big Papi, spaghetti, and so on? <span class="peekaboo-ref" id="nonsense">(Hint.)</span></p>
      
      <p id="note-nonsense" class="peekaboo-note shuttered">The brute-force method is to copy the expression <code class="language-javascript">Math.floor(Math.random() * 7)</code> three times, putting it into each of the array references. A better idea is to define a function—maybe call it <code>random7()</code>—with the statement <code class="language-javascript">return Math.floor(Math.random() * 7)</code> in the body.</p>
      
      <p>Arrays have still more tricks. For example, every array comes with a built-in method for reversing the order of its elements, and another for sorting them.</p>
      
      <p>Whereas arrays let you put items in numerical order, objects organize things by naming them. A name, or <em>key</em>, is a text string or anything that JavaScript <span class="peekaboo-ref" id="object-keys">can turn into a string.</span> Each key is associated with a value, which can be pretty much anything—a string, a number, an array, another object. In written form, an object is a list of key:value pairs separated by commas and enclosed in curly braces, like so:</p>
      
      <p id="note-object-keys" class="peekaboo-note shuttered">All the keys in an object are treated as if they were strings, even if they are not wrapped in quotation marks. For example, the key in the object <code class="language-javascript">{pi: 3.142}</code> is really <code class="language-javascript">"pi"</code>, and in <code class="language-javascript">{3.142: "pi"}</code> the key is not the number <code class="language-javascript">3.142</code> but the five-character string <code class="language-javascript">"3.142"</code>. When a key is a string that includes whitespace characters, quotation marks are mandatory: <code class="language-javascript">{"the key": "the value"}</code>. Moreover, with such keys the object’s property values can be accessed only with the array-like notation <code class="language-javascript">obj["the key"]</code>; the dotted form <code class="language-javascript">obj."the key"</code> won’t work.</p>
      
      <ul>
        <li><code class="language-javascript">{"the key": "the value"}</code></li>
        <li><code class="language-javascript">{name: "tungsten", symbol: "W", "atomic number": 74, mass: 183.84}</code></li>
        <li><code class="language-javascript">{pi: 3.142, phi: 1.618, e: 2.718"}</code></li>
        <li><code class="language-javascript">{3.142: "pi", 1.618: "phi", 2.718: "e"}</code></li>
        <li><code class="language-javascript">{coins: [1, 5, 10, 25, 50], bills: [1, 2, 5, 10, 20, 50, 100]}</code></li>
        <li><code class="language-javascript">{play: "Hamlet", cast: {"Ghost": "Shakespeare", "Hamlet": "Burbage"}}</code></li>
      </ul>
      
      <p>You can access object properties much as you do array elements, by putting the quoted key in square brackets. There’s also a shortcut “dotted” notation that is used much more often. Try it out (and remember you can edit this and add your own code):</p>

<div class="cm-div" id="objs" data-output-height="80px">
<textarea class="cm">var famousNumbers = {pi: 3.142, phi: 1.618, e: 2.718};

console.log("pi = " + famousNumbers["pi"]);  // array-like syntax
console.log("phi = " + famousNumbers.phi);   // dotted syntax

famousNumbers.root2 = 1.414;   // insert a new key-value pair
famousNumbers["Boston snow record"] = 110.6;  // another new entry
famousNumbers.pi = Math.PI;   // change stored value associated with "pi"
console.log(famousNumbers);
</textarea>
</div>
           
      <p>As lines 6 and 7 show, you can add new key:value pairs; in line 8, we alter the value of an existing property. There are also provisions for deleting properties and iterating through all the properties of an object.</p>
           
      <p>Objects provide a versatile scheme for storing and retrieving almost any kind of information. As a matter of fact, just about everything in JavaScript is an object when you look under the covers.</p>
            
      
      <h4>Variables</h4>
      
      <p>A rite of passage when you go from elementary school arithmetic to high school algebra is the introduction of <em>variables</em>—when you learn to solve for <em>x</em>. Variables are also crucial to computer programming, although their semantics is subtly different. The mathematical equation <em>x</em>&nbsp;=&nbsp;<em>y</em>&nbsp;+&nbsp;1 states a relationship: The value of <em>x</em> is equal to <em>y</em> + 1, no matter what the specific values of <em>x</em> and <em>y</em> happen to be at any given moment. In JavaScript, <code class="language-javascript">x = y + 1</code> is not an equation but an assignment statement; when the statement is executed, it looks up the current value of <code>y</code> at that moment, adds 1, then sets the value of <code>x</code> equal to the result. The equation <em>states</em> something; the assignment statement <em>does</em> something.</p>
      
      <p>In several of the code snippets above, you have already seen variables and assignment statements. Variables are introduced (or <em><span class="peekaboo-ref" id="declarations">declared</span></em>) with the keyword <code class="language-javascript">var</code>. You can assign the variable an initial value if you wish, and you can bundle several declarations into a single statement.</p>
      
      <p id="note-declarations" class="peekaboo-note shuttered">If you neglect to declare a variable, JavaScript won’t complain. However, the undeclared variable will have <em>global scope</em>: It will be accessible everywhere in the program, and perhaps even in other JavaScript programs running on the same web page. That’s asking for trouble, since the same variable name could be used elsewhere for another purpose.</p>
      
      <ul>
        <li><code class="language-javascript">var x = 0; // initial value is 0</code></li>

        <li><code class="language-javascript">var y;     // value of y is "undefined"</code></li>
        
        <li><code class="language-javascript">var a = "alpha", b = "beta", q, w; // four variables declared, two with values</code></li>
      </ul>
      
      <p>Variable names (a.k.a., <em>identifiers</em>) can be spelled with uppercase and lowercase letters as well as the underscore and dollar sign characters (_, $). Decimal digits are also allowed, except that a digit cannot be the first character. Nothing else is allowed in a name, in particular no spaces or hyphens or other punctuation. Case matters: <code>Lex</code>, <code>lex</code>, and <code>LEX</code> are all different identifiers. A common practice among JavaScripters is to write names in <em>CamelCase</em>: Words are squished together, with the first letter of each word capitalized. Names of variables and functions are done in <em>sulkingCamelCase</em>, with the very first letter lowercased, but objects are named in <em>PrancingCamelCase</em>, with head held high.</p>
      
      <p>It’s worth emphasizing that the JavaScript system doesn’t care in the least what you name your functions and variables (as long as the names are legal). <code class="language-javascript">function add1(n) { return n + 1 }</code> and <code class="language-javascript">function whynot(asparagus) { return asparagus + 1 }</code> perform exactly the same computation. Choose names that are meaningful to <em>you</em>.</p>
      
      <p>A JavaScript variable can hold any kind of value, and the data type can change whenever the variable is assigned a new value. In the sequence of statements <code class="language-javascript">var r = 4; r = "NESW"; r = ['a', 'b', 'c']</code>, <code>r</code> holds first a number, then a string, and finally an array.</p>
      
     
      <h4>Comparisons</h4>
      
      <p>As noted above, the JavaScript statement <code class="language-javascript">x = y + 1</code> assigns to <code>x</code> the value <code>y + 1</code>. The expression <code class="language-javascript">x === y + 1</code> is quite different. This one asks a question—Is <code>x</code> equal to <code>y + 1</code>?—and returns a value of <code>true</code> or <code>false</code> as the answer. For example:</p>
      
      <ul>
        <li><code class="language-javascript">3 * 4 === 2 * 6  // returns true</code></li>
        <li><code class="language-javascript">3 * 4 === 3 + 4  // returns false</code></li>
        <li><code class="language-javascript">4 === "four"  // returns false</code></li>
        <li><code class="language-javascript">"five" === "five"  // returns true</code></li>
        <li><code class="language-javascript">"five" === "Five"  // returns false</code></li>
      </ul>
      
      <p>JavaScript actually has two equality operators, <code>==</code> and <code>===</code>. The triple equal sign applies a <span class="peekaboo-ref" id="equality">stricter standard</span> of what it means for two things to be equal; you’ll seldom go wrong if you stick to the strict one. Likewise the two <em>inequality</em> operators, <code>!=</code> and <code>!==</code>, differ on what it means to be different. Again, the strict version <code>!==</code> is preferred.</p>
      
      <p id="note-equality" class="peekaboo-note shuttered">The difference between the two equality operators shows up when you compare values that have different data types, such as a number and a string. For example, <code class="language-javascript">0 === "0"</code> returns <code>false</code>, but <code class="language-javascript">0 == "0"</code> returns <code>true</code> because JavaScript converts the string to a number.</p>
      
      <p>Alongside the equality/inequality operators are four more operators that define the relations greater-than (<code>></code>), less-than (<code>&lt;</code>), greater-than-or-equal (<code>>=</code>), and less-than-or-equal (<code>&lt;=</code>). Applying these comparisons to numerical values is straightforward. They are also defined for text strings, with the notion of greater and less determined by alphabetical order.</p>
      
      
      <h4>If, Then, Else</h4>
      
      <p>The usual reason for comparing data elements is to make decisions that control the sequence of events in a program. If <em>x</em> is greater than <em>y</em>, do one thing; if not, do another. In JavaScript this branching process works as follows:</p>

<div class="cm-div" id="ifelse" data-output-height="50px">
<textarea class="cm">
function difference(x, y) {
  if (x > y) {          // predicate
        return x - y;   // consequent
      }
      else {
        return y - x;   // alternative
      }
}

console.log(difference(15, 7));
console.log(difference(7, 15));
</textarea>
</div>
          
      <p>Immediately following the keyword <code>if</code> is an expression wrapped in parentheses, called a <em>predicate</em>; the predicate must return a value that JavaScript can interpret as either <code>true</code> or <code>false</code>. (The parentheses are mandatory, by the way.) The next statement or block of statements, called the <em>consequent</em>, is executed if the predicate is <code>true</code>; if the predicate is <code>false</code>, the consequent is ignored. The <code>else</code> clause is optional. If an <code>else</code> is present, the statement labeled <em>alternative</em> is executed.</p>
      
      <p>A single <code>if</code> statement is usually easy to understand, but the logic can grow tangled when multiple <code>if</code>s and <code>else</code>s are combined or nested inside one another.</p>
           
      <p>JavaScript has two other variations on this theme of making choices. The <code>switch</code> statement allows for multiway decisions. If an expression can return three possible values—say, <code>"yes"</code>, <code>"no"</code>, and <code>"maybe"</code>—a single <code>switch</code> statement can direct the program down three different pathways. The <em>conditional operator</em> is like the <code>if</code> statement in that it handles just two options, but instead of executing one statement or another, it returns one value or another.</p>
      

      <h4>Loops</h4>
      
      <p>Running around in circles sounds unproductive, but looping or iteration is an essential element of almost all programs. JavaScript has two main constructs for looping, called <code>for</code> and <code>while</code>.</p>
      
      <p>A <code>for</code> loop executes a block of statements for a <span class="peekaboo-ref" id="for-loop-index">fixed number</span> of times.</p>
      
      <p id="note-for-loop-index" class="peekaboo-note shuttered">Well, the number of iterations isn’t necessarily fixed. If you fiddle with the index variable in the body of the loop, anything could happen. Not recommended. There is also a <code>break</code> statement that prematurely exits the loop.</p>

<div class="cm-div" id="loops" data-output-height="50px">
<textarea class="cm">
function factorialFor(n) {
  var result = 1, i;
  for (i = 1; i &lt;= n; i = i + 1) {
    result = result * i;
  }
  return result;
}

console.log(factorialFor(10));</textarea>
</div>
           
      <p>The soup of symbols in parentheses on line 2 is what controls the iteration. It has three parts. First, <code class="language-javascript">i = 1;</code> gives the loop counter, or index, an initial value of 1. This statement is executed just once, when the <code>for</code> loop is first entered. Next, <code class="language-javascript">i &lt;= n;</code> is a test applied just before each pass through the loop. If the test returns <code>true</code>, looping continues; otherwise, the whole process comes to an end. Third, <code class="language-javascript">i = i + 1</code> updates the value of <code>i</code> at the end of each iteration.</p>
      
      <p>The statement on line 4 is the <em>body</em> of the loop; this is what gets executed repeatedly, in this case <code>n</code> times. On each interation, <code>result</code> is multiplied by the current value of <code>i</code>. When the looping is done, <code>result</code> has accumulated a value of 1 &times; 2 &times; 3 &times; . . . &times; <em>n</em>, which is called the factorial of <em>n</em>.</p>
      
      <p>Quick exercise: Put a <code>console.log()</code> statement inside the loop, so that you can see a running record of how the value of <code>result</code> grows with each interation. <span class="peekaboo-ref" id="for-loop-log">Answer</span>.</p>
      
      <p id="note-for-loop-log" class="peekaboo-note shuttered">
      <code class="language-javascript">
for (i = 1; i &lt;= n; i = i + 1) {
  result = result * i;
  console.log(i, result);
}</code></p>
      
      <p>By the way, statements like <code class="language-javascript">i = i + 1</code> are often written in the shortcut notation <code class="language-javascript">i += 1</code>, where the <code>+=</code> does both the addition and the assignment. There’s a whole set of such shortcuts, including <code>-=</code>, <code>*=</code>, and <code>/=</code>. And there are even shorter cuts when all you need to do is add or subtract 1: <code>i++</code> and <code>i--</code>.</p>
      
       <p>A <code>while</code> loop keeps repeating a block of statements until some stated condition is no longer true. In the code below, the controlling condition is <code>(n &gt;= 0)</code>. In the body of the <code>while</code> loop, we multiply <code>result</code> by the current value of <code>n</code>. The output of the function is identical to that of the <code>for</code>-loop version above. But if you put a <code>console.log()</code> statement inside the loop, you’ll see that the computation takes a different path to that answer.</p>

<div class="cm-div" id="while" data-output-height="50px">
<textarea class="cm">
function factorialWhile(n) {
  var result = 1;
  while (n > 0) {
    result *= n;
    n -= 1;        // don't forget to decrement n
  }
  return result;
}

console.log(factorialWhile(10))
</textarea>
</div>
           
      <p>The <code>for</code> and <code>while</code> loops look different on the page, but they are hardly distinguishable at a deeper level. The choice is often a matter of taste or temperament. Still another way of getting the same answer really is different. The process is known as recursion.</p>

<div class="cm-div" id="recur" data-output-height="50px">            
<textarea class="cm">
function factorialRecur(n) {
  if (n &lt;= 1) {
    return 1;
  }
  else {
    return n * factorialRecur(n - 1);
  }
}

console.log(factorialRecur(10));
</textarea>
</div>
          
      <p>This time there’s no explicit looping structure in evidence—no <code>for</code>, no <code>while</code>. Instead, there’s an <code>if</code> statement, and a call to the very function we are in the midst of defining. The basic idea is that calculating the factorial of <em>n</em> is easy if you happen to know the factorial of <em>n – 1</em>: Just multiply by <em>n</em>. So you “recurse” back through successively smaller values of <em>n</em> until you eventually come to <em>n</em> = 1, where there’s no more work to do.</p>
      
      
      <h4>Scripting the Web</h4>
      
      <p>So far, we’ve been writing code whose only way of talking back to us is by posting messages to the console. That’s a useful protocol for learning the language and for testing and debugging, but it’s not how most JavaScript programs behave. Instead, they create or manipulate elements of the web page in which they are embedded. Here’s a trivial example, just to illustrate how JavaScript is able to grab hold of web page content and change its appearance. When you click the <code class="button">Run</code> button for the function below, all the subheadings in this page turn bright blue. (Click again to restore the original gray color.)</p>

<div class="cm-div" id="bluhed" data-output-height="50px">      
<textarea class="cm">
function blueheds() {
  subheds = document.getElementsByTagName("h4");
  for (var i = 0; i &lt; subheds.length; i++) {
    if (subheds[i].style.color === "blue") {
      subheds[i].removeAttribute("style");
    }
    else {
      subheds[i].style.color = "blue";
    }
  }
}

blueheds();
</textarea>
</div>
           
      <p>To understand what’s going on here, you need to know not just JavaScript but also the other languages that go into making things on the Web: HTML, or Hypertext Markup Language, and CSS, or Cascading Style Sheets. (Three languages just to put a splash of color on the screen! Yes, it’s a bit much, but it’s not totally crazy. HTML is for the substance of the page, the content and structure—the nouns. CSS describes how things look—the adjectives. JavaScript makes it move—the verbs.)</p>
      
      <p>Since we won’t be needing the JavaScript console just now, we can use the space it occupies on the screen for another purpose—to examine the HTML source code of this web page. Put your mouse pointer on the subhead “Scripting the Web” and <span class="peekaboo-ref" id="right-click">right-click</span>; in the drop-down menu, find and select the item “Inspect Element.” A new panel will open, showing the HTML source code with the subheading highlighted. It will look like this:</p>
      
      <p id="note-right-click" class="peekaboo-note shuttered">This should work in all of the major browsers. If you’re on a Macintosh with a one-button mouse, “right-click” === “option-click”. There are also menu commands to open the inspector.</p>
      
      <p><code class="language-markup">&lt;h4&gt;Scripting the Web&lt;/h4&gt;</code></p>
      
      <p>Or maybe like this, if you have run the <code>bluheds</code> program an odd number of times:</p>
      
      <p><code class="language-markup">&lt;h4 style="color: blue"&gt;Scripting the Web&lt;/h4&gt;</code></p>
      
      <p>If you now press the <code class="button">Run</code> button a few times more, you’ll see exactly what the <code>bluheds</code> function is doing. It inserts and removes a <code>style="color: blue"</code> annotation within the <code>&lt;h4&gt;</code> <span class="peekaboo-ref" id="HTML-tags">HTML tag</span>.</p>
      
      <p id="note-HTML-tags" class="peekaboo-note shuttered">HTML tags, characteristically enclosed in angle brackets, label the elements of an HTML document. <code>&lt;h4&gt;</code> is a level-four heading, <code>&lt;p&gt;</code> is a paragraph, and so on. Almost all of them require a matched closing tag, such as <code>&lt;/p&gt;</code></p> 
      
      <p>Let’s go through the function line by line. The <code>document.getElementsByTagName("h4")</code> method sifts through the entire web page and compiles a list of all elements tagged <code>&lt;h4&gt;</code>; the list, packaged as a special kind of array, is assigned to the variable <code>subheds</code>. The <code>for</code> loop steps through the array and examines each <code>&lt;h4&gt;</code> element in turn. If the element already has a <code>style</code> attribute specifying <code>color: "blue"</code>, the <code>removeAttribute</code> method is invoked. It does just what the name suggests, <span class="peekaboo-ref" id="removal">removing</span> the entire <code>style</code> attribute from the <code>&lt;h4&gt;</code> element. Otherwise, a new <code>style.color = "blue"</code> attribute is added to the element. The browser does the rest, reading the attributes of each element and displaying it appropriately.</p>
      
      <p id="note-removal" class="peekaboo-note shuttered">Removing the entire attribute is not really the best way to do this. The element might have other styles applied, and bluheds would clobber them all. A better strategy is to add and remove a <code>class</code> attribute, such as <code>class="blue"</code>, and then put the styling information in a separate CSS file.</p>
      
      <p>The basic strategy employed by the <code>bluheds</code> function is a very common one in JavaScript programs. First you gather together all the HTML elements you want to work with, and store pointers to them in a JavaScript variable. Then you act on the elements one by one. You can also create new elements or delete existing ones. It’s a pretty simple recipe, but with a computer that can chomp through many thousands of elements per second, it can achieve some stunning visual effects.</p>

      <h4>Graphics</h4>
      
      <p>For scientific visualizations, you need more than multicolor subheads. You need graphics: the ability to draw or paint on the screen. JavaScript has access to two graphics systems within the browser, called the <code>canvas</code> element and Scalable Vector Graphics, or SVG. Although they work quite differently, for many purposes they can produce similar results. On a canvas you draw by invoking methods such as <code>arc()</code> or <code>line()</code>, which paint the appropriate pixels. Once such an object has been drawn, you can no longer move it or change it or even erase it. You can only paint a new object over it. SVG constructs a drawing from persistent graphical objects, closely analogous to the elements of an HTML document. You can move them around or alter their properties, and the displayed drawing will change to match. SVG is more versatile but also more complicated. Here we’re going to construct an elementary demo of drawing on the canvas.</p>

<div class="cm-div" id="bubbles" data-output-height="50px">
<textarea class="cm">
function bubbles(n) {

  var cv, cvx, w, h, maxRadius, timer;   // vars local to bubbles

  cv = document.getElementById("bubbles-canvas"); // store ref to canvas
  w = cv.width;                         // get dimensions
  h = cv.height;
  cv.width = w;                         // reset to blank canvas
  maxRadius = Math.min(w, h) * 0.5;     // largest bubble
  cvx = cv.getContext("2d");
  timer = setInterval(drawBubble, 200);   // call every 200 milliseconds

  // will be called at intervals by setInterval
  function drawBubble() {                // draw one random bubble
    var x, y, r, c;                      // vars local to drawBubble
    x = w * Math.random();               // random coords of bubble center
    y = h * Math.random();               //    "      "    "    "      "
    r = maxRadius * Math.random();       // random radius
    c = randomColor();                   // random color
    cvx.fillStyle = c;
    cvx.beginPath();
    cvx.arc(x, y, r, 0, 2 * Math.PI, true);
    cvx.fill();
    n -= 1;                              // countdown until we have n bubbles
    if (n === 0) { clearInterval(timer) };   // cancel the setInterval
  }
}

function random16Bit() {                   // random int 0 &lt;= n &lt;= 255
  return Math.floor(256 * Math.random());
}
  
function randomColor() {                   // assemble three random values
  return "rgba(" +                         // into a string representing
    random16Bit() + "," +                  // and RGBA color value
    random16Bit() + "," + 
    random16Bit() + "," +
    "0.5)";                                // set transparency to 50%
}

bubbles(50);      // draw 50 bubbles
</textarea>
</div>
          
      <div id="bubbles-div">
        <canvas id="bubbles-canvas" width="500px" height="275px"></canvas>
      </div>
      
      <p>The rectangle above is a blank canvas. If you do an <code>Inspect Element</code> on it, you’ll find it has an <code>id</code> of <code>bubbles-canvas</code>. The canvas is blank because we haven’t yet drawn anything in it. Press the <code class="button">Run</code> button to fix that.</p>

      <p>How does it work? The comments in the code will explain much, but I’d like to call attention to a few more points.</p>
      
      <ul>
        <li>For the first time we’re seeing a function defined inside another function. I have done it this way so that the inner function (<code>drawBubble</code>) will have access to the local variables of the outer function (<code>bubbles</code>).</li>
        
        <li>Lines 5, 6, and 7 store references to the canvas and its dimensions, then line 8 does something odd: It sets the canvas width to the same value it already has. Huh? This is simply an idiom for clearing the canvas to a blank state.</li>
        
        <li>Line 10, <code class="language-javascript">cvx = cv.getContext("2d");</code>, represents one of those annoying technicalities that I would sweep under the rug if only I could. Turns out we don’t actually draw on the canvas; we draw on a two-dimensional “context” object that’s part of the canvas. (Yes, there is also a three-dimensional context.) All of the drawing commands are methods of the context object <code>cvx</code>.</li>
        
        <li>The <code>setInterval</code> function in line 11 is something new. We could have defined a <code>for</code> loop to draw <em>n</em>bubbles, but they would be drawn so quickly that they would all appear on the screen instantly. <code>setInterval</code> slows the action down so that we can see individual bubbles popping into existence. It makes a call to <code>drawBubble</code> every 200 milliseconds, or in other words five times a second.</li>
        
        <li>Inside the <code>drawBubble</code> function, we choose a random center point, radius, and color for each bubble (lines 15 to 19). Then lines 20 through 23 do the actual drawing, invoking methods of the <code>cvx</code> object. <code>fillStyle</code> is set to the random color we just computed; <code>beginPath()</code> resets the state of the drawing system; <code>arc()</code> draws a circle; and finally <code>fill()</code> fills the new circle with the chosen color. The six arguments to <code>arc()</code> specify the geometry of the circle as follows:</li>
        <ul>
          <li><code>x</code>: <em>x</em> coordinate of the center point</li>
          <li><code>y</code>: <em>y</em> coordinate of the center point</li>
          <li><code>r</code>: radius</li>
          <li><code>0</code>: starting angle of the arc to be drawn</li>
          <li><code>2 * Math.PI</code>: ending angle in radians; (2π radians === 360 degrees)</li>
          <li><code>true</code>: go clockwise around the arc; doesn’t matter in this case</li>
        </ul>
        
        <li>The <code>setInterval</code> timer will keep drawing bubbles forever, five of them a second, if we don’t stop it. That’s the function of lines 24 and 25. Each time we draw a bubble, we also decrement the value of <code>n</code>; when the value reaches zero, we cancel the timer.</li>
      </ul>
      
      <p>There are lots of opporunties for exploring and experimenting with this code. At the simplest level, you might change the number of bubbles to draw or the rate at which they are drawn. Or make the bubbles hollow by changing <code>fill()</code> to <code>stroke()</code> and <code>fillStyle</code> to <code>strokeStyle</code>.) If you’re feeling more ambitious, you could try drawing rectangular bubbles. The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API#Reference">Mozilla reference</a> on <code>canvas</code> will tell you how that’s done. You’re in charge here.</p>
      
      
      <h4>What’s Next</h4>

      <p>If you’d like to get a head start on a project of your own, download <a href="templates/templates.zip">templates.zip</a>, which has skeleton versions of HTML, CSS, and JavaScript files you can use as a starting point. You can open them all in the Brackets editor. Or you might want to take a look at a <a href="ising/ising.html">little project of mine</a> that I’ll be discussing at the workshop.</p> 

     
    </div> <!--"content"-->
     
     <script src="js/nav.js"></script>
     <script src="js/footnotes.js"></script>
     <script src="js/prism.js"></script>
     <script src="js/codemirror.js"></script>
     <script src="js/matchbrackets.js"></script> <!-- CodeMirror addon -->
     <script src="js/javascript.js"></script> <!-- CodeMirror js mode -->
     <script src="js/make-editor.js"></script> <!-- my script for running CodeMirror panels -->
     <script src="js/dla-small.js"></script>

  </body>
</html>
